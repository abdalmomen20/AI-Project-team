import heapq

N = 5

def is_safe(state, row, col):
    for r, c in enumerate(state):
        if c == col or abs(c - col) == abs(r - row):
            return False
    return True

def heuristic(state):
    conflicts = 0
    for i in range(len(state)):
        for j in range(i + 1, len(state)):
            if state[i] == state[j] or abs(state[i] - state[j]) == abs(i - j):
                conflicts += 1
    return conflicts

def astar_5_queens():
    priority_queue = []
    heapq.heappush(priority_queue, (0, 0, []))  # (f, g, state)

    while priority_queue:
        f, g, state = heapq.heappop(priority_queue)
        row = len(state)

        if row == N and heuristic(state) == 0:
            return state

        for col in range(N):
            if is_safe(state, row, col):
                new_state = state + [col]
                g_new = g + 1
                h_new = heuristic(new_state)
                f_new = g_new + h_new
                heapq.heappush(priority_queue, (f_new, g_new, new_state))

    return None

solution = astar_5_queens()
print(solution)
